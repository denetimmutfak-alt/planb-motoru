#!/usr/bin/env python3
"""
PlanB Motoru - Ultra Advanced Telegram Bot
Production-Ready with Auto-Decision Capability
"""

import asyncio
import json
import os
from datetime import datetime
from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import sqlite3
import requests
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
API_BASE_URL = "http://localhost:8001"
DB_PATH = "data/planb_ultra.db"

class UltraTelegramBot:
    def __init__(self):
        self.bot_token = BOT_TOKEN
        self.chat_id = CHAT_ID
        self.application = None
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Start command handler"""
        welcome_message = """
üöÄ **PlanB Motoru Ultra Bot Aktif!**

‚úÖ **√ñzellikler:**
‚Ä¢ Real-time market sinyalleri
‚Ä¢ ML-destekli analiz sonu√ßlarƒ±  
‚Ä¢ Otomatik karar onay sistemi
‚Ä¢ Risk y√∂netimi ve portf√∂y takibi

üìä **Komutlar:**
/status - Bot durumu
/signals - Son sinyaller
/stats - Sistem istatistikleri
/help - Yardƒ±m

üéØ **Durum:** ULTRA OPERATIONAL
        """
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Status command handler"""
        try:
            # Get API health
            response = requests.get(f"{API_BASE_URL}/health", timeout=5)
            health_data = response.json()
            
            # Get database stats
            conn = sqlite3.connect(DB_PATH)
            cursor = conn.cursor()
            
            cursor.execute("SELECT COUNT(*) FROM analysis_results WHERE timestamp > datetime('now', '-1 hour')")
            recent_signals = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM user_decisions WHERE execution_status = 'pending'")
            pending_decisions = cursor.fetchone()[0]
            
            conn.close()
            
            status_message = f"""
üî• **SISTEM DURUMU - ULTRA STABLE**

‚ö° **API Status:** {health_data['status']}
üìä **Database:** {health_data['database']['status']}
ü§ñ **ML Engine:** {health_data['services']['ml_engine']}

üìà **Son 1 Saat:**
‚Ä¢ Yeni Sinyaller: {recent_signals}
‚Ä¢ Bekleyen Kararlar: {pending_decisions}
‚Ä¢ Uptime: {health_data['performance']['uptime']}

üéØ **Performans:** EXCELLENT
‚è∞ **Son G√ºncelleme:** {datetime.now().strftime('%H:%M:%S')}
            """
            
            await update.message.reply_text(status_message, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"‚ùå Status alƒ±namadƒ±: {str(e)}")
    
    async def signals_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Get latest signals"""
        try:
            response = requests.get(f"{API_BASE_URL}/api/v1/analysis?limit=5", timeout=10)
            signals = response.json()
            
            if not signals:
                await update.message.reply_text("üì≠ Aktif sinyal bulunamadƒ±.")
                return
            
            message = "üéØ **SON Sƒ∞NYALLER:**\n\n"
            
            for signal in signals:
                confidence_emoji = "üü¢" if signal['confidence'] > 0.8 else "üü°" if signal['confidence'] > 0.6 else "üî¥"
                signal_emoji = "üìà" if "BUY" in signal['signal'] else "üìâ" if "SELL" in signal['signal'] else "‚è∏Ô∏è"
                
                message += f"""{signal_emoji} **{signal['symbol']}**
Signal: `{signal['signal']}`
Confidence: {confidence_emoji} `{signal['confidence']:.1%}`
ML Score: `{signal['ml_score']:.1f}/100`
Time: `{signal['timestamp'][:16]}`

"""
            
            await update.message.reply_text(message, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"‚ùå Sinyaller alƒ±namadƒ±: {str(e)}")
    
    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Get system statistics"""
        try:
            response = requests.get(f"{API_BASE_URL}/api/v1/stats", timeout=10)
            stats = response.json()
            
            message = f"""
üìä **Sƒ∞STEM ƒ∞STATƒ∞STƒ∞KLERƒ∞**

üè¢ **Market Data:**
‚Ä¢ Takip Edilen Semboller: {stats['market_data']['unique_symbols']}
‚Ä¢ Son 24s Veri Noktasƒ±: {stats['market_data']['recent_data_points']}

ü§ñ **ML Analiz (24s):**
‚Ä¢ Toplam Tahmin: {stats['analysis']['total_predictions_24h']}
‚Ä¢ Y√ºksek G√ºven Sinyalleri: {stats['analysis']['high_confidence_signals']}

üéØ **En ƒ∞yi Sinyaller:**
"""
            
            for signal in stats['top_signals']:
                message += f"‚Ä¢ {signal['symbol']}: {signal['signal']} ({signal['confidence']:.1%})\n"
            
            message += f"\n‚ö° **Sistem Saƒülƒ±ƒüƒ±:** {stats['system_health']}"
            
            await update.message.reply_text(message, parse_mode='Markdown')
            
        except Exception as e:
            await update.message.reply_text(f"‚ùå ƒ∞statistikler alƒ±namadƒ±: {str(e)}")
    
    async def send_signal_notification(self, signal_data):
        """Send signal notification with approval buttons"""
        symbol = signal_data['symbol']
        signal = signal_data['signal']
        confidence = signal_data['confidence']
        
        # Determine emoji and color based on signal
        if "BUY" in signal:
            emoji = "üìà"
            color = "üü¢"
        elif "SELL" in signal:
            emoji = "üìâ" 
            color = "üî¥"
        else:
            emoji = "‚è∏Ô∏è"
            color = "üü°"
        
        confidence_emoji = "üöÄ" if confidence > 0.8 else "‚ö°" if confidence > 0.7 else "‚ö†Ô∏è"
        
        message = f"""
{emoji} **YENƒ∞ Sƒ∞NYAL - {symbol}**

üéØ **Signal:** `{signal}`
{confidence_emoji} **Confidence:** `{confidence:.1%}`
üìä **ML Score:** `{signal_data.get('ml_score', 0):.1f}/100`
‚è∞ **Time:** `{datetime.now().strftime('%H:%M:%S')}`

üí° **Recommendation:** {signal_data.get('recommendation', 'Monitor')}
‚öñÔ∏è **Risk Level:** {signal_data.get('risk_level', 'Medium')}
        """
        
        # Create approval buttons
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ Onayla", callback_data=f"approve_{symbol}_{signal}"),
                InlineKeyboardButton("‚ùå Reddet", callback_data=f"reject_{symbol}_{signal}")
            ],
            [
                InlineKeyboardButton("üìä Detay", callback_data=f"details_{symbol}"),
                InlineKeyboardButton("‚è≥ Beklet", callback_data=f"hold_{symbol}_{signal}")
            ]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Send to configured chat
        bot = Bot(token=self.bot_token)
        message_obj = await bot.send_message(
            chat_id=self.chat_id,
            text=message,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
        
        # Store decision request in database
        self.store_decision_request(symbol, signal, message_obj.message_id)
        
        return message_obj.message_id
    
    def store_decision_request(self, symbol, signal, message_id):
        """Store decision request in database"""
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO user_decisions 
            (symbol, signal, telegram_message_id, execution_status)
            VALUES (?, ?, ?, 'pending')
        """, (symbol, signal, message_id))
        
        conn.commit()
        conn.close()
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle button callbacks"""
        query = update.callback_query
        await query.answer()
        
        callback_data = query.data
        action, symbol = callback_data.split('_', 1)
        
        if action == "approve":
            await self.handle_approval(query, symbol, True)
        elif action == "reject":
            await self.handle_approval(query, symbol, False)
        elif action == "details":
            await self.show_details(query, symbol)
        elif action == "hold":
            await self.handle_hold(query, symbol)
    
    async def handle_approval(self, query, symbol_signal, approved):
        """Handle signal approval/rejection"""
        symbol, signal = symbol_signal.rsplit('_', 1)
        
        # Update database
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        status = 'approved' if approved else 'rejected'
        cursor.execute("""
            UPDATE user_decisions 
            SET user_action = ?, execution_status = ?
            WHERE telegram_message_id = ?
        """, (status, 'executed' if approved else 'cancelled', query.message.message_id))
        
        conn.commit()
        conn.close()
        
        # Update message
        action_emoji = "‚úÖ" if approved else "‚ùå"
        action_text = "ONAYLANDI" if approved else "REDDEDƒ∞LDƒ∞"
        
        new_text = f"{query.message.text}\n\n{action_emoji} **KARAR: {action_text}**\n‚è∞ {datetime.now().strftime('%H:%M:%S')}"
        
        await query.edit_message_text(text=new_text, parse_mode='Markdown')
        
        # Send execution confirmation
        if approved:
            await query.message.reply_text(f"üöÄ **{symbol}** i√ßin **{signal}** sinyali execute edildi!")
    
    async def show_details(self, query, symbol):
        """Show detailed analysis for symbol"""
        try:
            response = requests.get(f"{API_BASE_URL}/api/v1/market-data?symbol={symbol}&limit=1", timeout=5)
            market_data = response.json()
            
            response = requests.get(f"{API_BASE_URL}/api/v1/analysis?symbol={symbol}&limit=1", timeout=5)
            analysis_data = response.json()
            
            if market_data and analysis_data:
                market = market_data[0]
                analysis = analysis_data[0]
                
                details = f"""
üìä **{symbol} - DETAYLI ANALƒ∞Z**

üí∞ **Market Data:**
‚Ä¢ Price: ${market['price']:.2f}
‚Ä¢ Volume: {market['volume']:,}
‚Ä¢ Change: {market.get('change_percent', 0):.2f}%
‚Ä¢ RSI: {market.get('rsi', 0):.1f}
‚Ä¢ MACD: {market.get('macd', 0):.3f}

ü§ñ **ML Analysis:**
‚Ä¢ Signal: {analysis['signal']}
‚Ä¢ Confidence: {analysis['confidence']:.1%}
‚Ä¢ ML Score: {analysis['ml_score']:.1f}/100
‚Ä¢ Model: {analysis['model_version']}

‚è∞ **Last Update:** {analysis['timestamp'][:16]}
                """
                
                await query.message.reply_text(details, parse_mode='Markdown')
            else:
                await query.message.reply_text("‚ùå Detay bilgi alƒ±namadƒ±.")
                
        except Exception as e:
            await query.message.reply_text(f"‚ùå Hata: {str(e)}")
    
    async def handle_hold(self, query, symbol_signal):
        """Handle hold action"""
        symbol, signal = symbol_signal.rsplit('_', 1)
        
        # Update database
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE user_decisions 
            SET user_action = 'hold', execution_status = 'pending'
            WHERE telegram_message_id = ?
        """, (query.message.message_id,))
        
        conn.commit()
        conn.close()
        
        new_text = f"{query.message.text}\n\n‚è≥ **KARAR: BEKLETƒ∞LDƒ∞**\n‚è∞ {datetime.now().strftime('%H:%M:%S')}"
        await query.edit_message_text(text=new_text, parse_mode='Markdown')
    
    def run_bot(self):
        """Run the telegram bot"""
        self.application = Application.builder().token(self.bot_token).build()
        
        # Add handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("signals", self.signals_command))
        self.application.add_handler(CommandHandler("stats", self.stats_command))
        self.application.add_handler(CallbackQueryHandler(self.handle_callback))
        
        print("ü§ñ Ultra Telegram Bot ba≈ülatƒ±lƒ±yor...")
        print(f"üì± Bot Token: {self.bot_token[:10]}...")
        print(f"üí¨ Chat ID: {self.chat_id}")
        print("‚úÖ Bot ULTRA OPERATIONAL!")
        
        # Run the bot
        self.application.run_polling()

if __name__ == "__main__":
    if BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
        print("‚ö†Ô∏è  Telegram Bot Token ayarlanmamƒ±≈ü!")
        print("üîß BOT_TOKEN ve CHAT_ID deƒüi≈ükenlerini d√ºzenleyin.")
    else:
        bot = UltraTelegramBot()
        bot.run_bot()